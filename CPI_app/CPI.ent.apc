{Application 'CPI' logic file generated by CSPro}
	 
PROC GLOBAL

	//*************************** Declarations **********************************************
	string shopsFileName, marketsFileName;		//list of all shops with interviewer IDs
	string productFileName;		//The products 
	
	numeric vsetMax = 200;		//Maximum number of items in dropdown boxes..
	numeric maxNumOfItems = 900;			//Maximum number of products to collect prices for

	
	array string menuCodes(vsetMax);	//Don't want to reset the menu every time I return to it, hence I declare it globally
	array string menuLabels(vsetMax);
	
	numeric changeProduct = 0;		//If the product needs to be replaced
	
	string currPeriod, prevPeriod;
	
	

	

//************************************* Functions ************************************************	

	//The names of the lookup files are dependent on what questionnaire and what language we are dealing with
	//This function sets the filenames right
	//The file name of the shops is decided after location has been selected.
	function getFileNames()
		string aDate = edit("99999999", dateadd(sysdate("YYYYMMDD"), -1, "m"));
		string MMYY = aDate[5:2] + aDate[3:2];
		string tmpMistoName = replace(strip(MISTO_NAME),  " ", "_");
		tmpMistoName = replace(tmpMistoName,  " ", "_");
		
		string folderName = "../Lookup/" + edit("99999", visualvalue(MISTO_NO)) + "_" + tmpMistoName + "/";
		shopsFileName = folderName + "d_shop_" + MMYY + ".txt";
		marketsFileName = folderName + "d_rinok_" + MMYY + ".txt";
	end;



	//If the interviewer wants to stop in the middle of the interview, we want him to go via the menu field first
	//The onstop menu handles this	
	function onstop()
		string lastField = getsymbol();
		//errmsg("last field: %s", lastField);
		if lastField = "PROD_PRICE" or lastField = "PROD_COMMENTS"  then
			move to PRODGROUP;	
		endif;
	end;




	//function to strip leading spaces (the original strip function only strips trailing spaces)
	function string lstrip(string theString)
		numeric aPos = pos(" ", theString);
		while aPos = 1 do
			//leading space
			theString = theString[2];
			aPos = pos(" ", theString);
		enddo;
		lstrip = theString;
	end;
	
	
	
	//Function to read a tab separated file into a multidimensional array
	
	// get numeric 3lvl coicop (ie. get rid of dots between digits)
	function getNum3Lvl(string str3Lvl)
		getNum3Lvl = toNumber(str3lvl[1:2] + str3lvl[4:1] + str3lvl[6:1]);
	end;
	

	//Function to fill the products roster given that shop has been chosen
	function fillProductsRoster()
		numeric rosterIdx = 1;
		
		forcase PRODUCTS_DICT where P_MISTO = visualValue(MISTO_NO) and P_SHOP_TYPE = visualValue(SHOP_TYPE) and P_SHOP = visualValue(SHOP) do
			PROD_NO(rosterIdx) = visualValue(P_PRODUCT);
			PROD_SUB_ID(rosterIdx) = visualValue(P_SUBID);
			PROD_COICOP(rosterIdx) = lStrip(P_COICOP);
			PROD_DESC(rosterIdx) = lstrip(P_PROD_DESC);
			PROD_PRICE_LAST_MONTH(rosterIdx) = visualValue(P_PRICE);
			PROD_UNIT(rosterIdx) = visualValue(P_UNIT);
			inc(rosterIdx);
		endfor;
	end;
	
		


PROC CPI_FF

PROC CPI_QUEST

preproc

	
	savesetting("CSEntry.Menu.ShowCaseTree", "No"); //preventing the case tree to be shown
	savesetting("Setting.ShowCaseTreeInOverlay", "No");
	
	if demode() = add then	//Only do this if in adding mode. Otherwise it is already set
		OBLAST_NO  = toNumber(sysparm("OBLAST"));
		MISTO_NO = toNumber(sysparm("MISTO"));
		MISTO_NAME = sysparm("MISTO_NAME");
		ENUMERATOR_NO = toNumber(sysparm("ENUMERATOR"));
		SHOP = toNumber(sysparm("SHOP"));
		SHOP_TYPE =toNumber(sysparm("SHOPTYPE"));
		SHOP_NAME = sysparm("SHOPNAME");
	endif;	
	
	
	setLanguage(sysparm("Language"));
	getFileNames();
	
	//reset the PRODGROUP
	numeric i = 0;
	while i < vsetMax do
		menuCodes(i) = "";
		menuLabels(i) = "";
		inc(i);
	enddo;

	//Also fill the products roster on next form, as this only needs to be done after shop is chosen
	if PROD_COICOP(1) = "" then
		fillProductsRoster();	//Only fill it if it hasn't been filled already
	endif;
	

	//Need to set the valueset of the PRODGROUP as well as the products roster if case is partially saved
	if ispartial() then
		ENDQUEST = NOTAPPL; 
		
		if visualvalue(SHOP_TYPE) in 1, 2 then
			//This is essentially the same as the preproc of PRODGROUP
			string theCodes = "";
			numeric menuIdx = 0;
			forcase PRODUCTS_DICT where P_MISTO = visualValue(MISTO_NO) and P_SHOP = visualValue(SHOP) and P_SHOP_TYPE = visualValue(SHOP_TYPE) do
				LVL3CODE = P_COICOP;
				
				//loop through to see if I added it already
				i = 0;
				string inserted = "false";
				while i < menuIdx do
					if menuCodes(i) = P_COICOP then
						inserted = "true";
						//break;
					endif;
					inc(i);
				enddo;
			
				if inserted = "true" then	//Already found this coicop code. Looping to next case
					next;
				endif;
			
				numeric ok = loadcase(COICOPLVL3_DICT, LVL3CODE);
				//errmsg("loadcase: %d, code: %s", ok, LVL3CODE);
				if ok then
					menuCodes(menuIdx) = LVL3CODE;
					menuLabels(menuIdx) = LVL3DESC;
					inc(menuIdx);
				endif;		
			endfor;
		
			menuCodes(menuIdx) = "999";
			menuLabels(menuIdx) = maketext(tr(105));	//quit
			menuCodes(menuIdx + 1) = "";
	
			//Setting whether a PRODGROUP item has been finished is done in the onfocus of PRODGROUP, not here - 
			//as this has to be done every time we return there anyway..	

			setValueset(PRODGROUP, menuCodes, menuLabels);		
			skip to PRODGROUP;
		else	//Monitoring survey..
			PRODUCT = "";
			skip to PRODUCT;
		endif;		
	endif;
	
	
	
postproc
	//When we reach the Questionnaire level postproc, the questionnaire is finished, and we
	//close down the application
	stop(1);
	
	
	
PROC COVER_PAGE_FORM
preproc
	//Need the file names to read from if they have already been set
	//otherwise, they're read in the preproc of MISTO_NO
	if (ispartial() or demode() = Modify) then
		getFileNames();
	endif;
	
	



PROC CPI_YEAR
preproc
	
	if demode() = add and not ispartial() then
		CPI_YEAR = sysdate("YYYY");
		CPI_MONTH = sysdate("MM");
		
	endif;




PROC MONTH_DAY
preproc	
	string tmpDate = edit("999999", sysdate());	//To get the leading zeros for month. returns YYMMDD
	MONTH_DAY = toNumber(tmpDate[3]);
	skip to HOUR_MINUTE;


PROC HOUR_MINUTE
preproc
	HOUR_MINUTE = systime("HHMM");
	skip to PRODGROUP;


PROC PRODGROUP
onfocus
	if visualValue(SHOP_TYPE) in 3,4 then	//Monitoring survey. Special case..
		//if PRODUCT = "999" then
			//want to quit the current shop
		//	skip to ENDQUEST;
		//else	//Don't need prod groups for monitoring survey)
			skip to PRODUCT;
		//endif;
	else
	$ = "";
	numeric menuIdx = 0;
	numeric ok = 0;
	String aLine;
	
	//First need to extract the coicop lvl3 codes and create the PRODGROUP that is relevant to the chosen shop
	if menuCodes(0) = "" then	
		string theCodes = "";
		 numeric numcases = countcases(PRODUCTS_DICT where P_MISTO = visualValue(MISTO_NO) and P_SHOP = visualValue(SHOP) and P_SHOP_TYPE = visualValue(SHOP_TYPE));
		 //errmsg("numcases: %d", numcases);
		 
		forcase PRODUCTS_DICT where P_MISTO = visualValue(MISTO_NO) and P_SHOP = visualValue(SHOP) and P_SHOP_TYPE = visualValue(SHOP_TYPE) do
			LVL3CODE = P_COICOP;
			
			//loop through to see if I added it already
			numeric i = 0;
			string inserted = "false";
			while i < menuIdx do
				if menuCodes(i) = P_COICOP then
					inserted = "true";
					//break;
				endif;
				inc(i);
			enddo;
			
			if inserted = "true" then	//Already found this coicop code. Looping to next case
				next;
			endif;
			
			ok = loadcase(COICOPLVL3_DICT, LVL3CODE);
				
			if ok then
				menuCodes(menuIdx) = LVL3CODE;
				menuLabels(menuIdx) = LVL3DESC;
				inc(menuIdx);
			endif;		
		endfor;
		
		menuCodes(menuIdx) = "999";
		menuLabels(menuIdx) = maketext(tr(105));	//quit
		menuCodes(menuIdx + 1) = "";
	endif;	


	//Loop through products roster to see if anything is already finished
	//Must be done every time the user returns to the menu, of course..
	numeric i = 0, j = 1;
	String currGroup = "";
	numeric filled;
	//while menuCodes(i) <> "999" and menuCodes(i) <> "" do
	while menuCodes(i) <> "" do
		if menuCodes(i) <> currGroup then
			if currGroup <> "" then
				//New group. Have to deal with the previous
				if filled = 1 then
					//The previous price group was all filled in
					//Setting "Finished text only if not already done
					string tmpString = makeText(tr(154));
					if pos(tmpString, menuLabels(i-1)) = 0 then
						string newstring = maketext(tr(154)) + strip(menuLabels(i-1));
						menuLabels(i-1) = newstring;
					endif;
				endif;
			endif;
			currGroup = menuCodes(i);
		endif;
		
		filled = 1;	
		j = 1;

		while j <= maxNumOfItems do
				
			if menuCodes(i) <> PROD_COICOP(j)[1:6] then 	//Not at the right spot in the roster. Looping on
				inc(j);
			else 
				if visualValue(PROD_PRICE(j)) = NOTAPPL then
					//The product group is not finished
					filled = 0;
					break;
				else
					inc(j);
				endif;
			endif;
		enddo;
		inc(i);
	enddo;
	
	setValueset(PRODGROUP, menuCodes, menuLabels);
	endif;


postproc 
	if $ = "999" then
		PRODUCT = "999";
		skip to ENDQUEST;
	else
		//Just continue
	endif;
	


PROC PRODUCT
onFocus
	//The preproc just sets the items in the dropdown, which are all the products for the selected group.
	numeric idx = 0;
	array string prodId(vsetMax); //For value set for PRODUCT field
	array string prodDescr(vsetMax);
	
	//For normal price collection
	//if SHOP_TYPE in 1,2 then
		numeric i = 1;
		while i < maxocc(PROD_REC000) do
			if lstrip(PROD_COICOP(i))[1:6] = PRODGROUP then
				if visualValue(PROD_NO(i)) <> NOTAPPL then
					prodId(idx) = edit('ZZZ', visualValue(PROD_NO(i))) + edit('ZZ', visualValue(PROD_SUB_ID(i)));
					if visualValue(PROD_PRICE(i)) = NOTAPPL then
						prodDescr(idx) = PROD_DESC(i);
						inc(idx);
					else
						prodDescr(idx) = makeText(tr(154)) + " " + PROD_DESC(i);
						inc(idx);
					endif;			
				endif;
			endif;
			inc(i)
		enddo;
	//else	//Monitoring. No 3-lvl coicop
	
	
	//Adding one to go back. To product group or to shop
	ProdId(idx) = "999";
	if SHOP_TYPE in 1,2 then
		ProdDescr(idx) = maketext(tr(157));
	else
		ProdDescr(idx) = maketext(tr(105));
	endif;
	prodId(idx+1) = '';
		
	setValueset(PRODUCT, prodId, ProdDescr);


postproc
	if $ <> "999" then	//continue collecting prices
	
		//Loop through the valueset of this field to get the description of the chosen product.
		i = 0;
		numeric currProd = 0;
		string description;
		while i < vsetMax do
			if prodId(i) = $ then
				//right one
				description = prodDescr(i);
				idx = i;
				break;
			endif;
			inc(i);
		enddo;

		//Also need to loop through the products rec to be able to set the price as default if already entered
		i = 1;
		while i < maxocc(PROD_REC000) do
			if visualValue(PROD_NO(i)) = toNumber(prodId(idx)[1:3]) 
						and visualValue(PROD_SUB_ID(i)) = toNumber(ProdId(idx)[4:2]) then
				//Found the right place
				currProd = i;				
				break;
			endif;
			inc(i)
		enddo;

			
		//get the price. Looping until it's correct or has reason why not
		numeric price = DEFAULT, change;
		while true do
			numeric prodUnit = visualValue(PROD_UNIT(currProd));
			numeric lastMonth = visualValue(PROD_PRICE_LAST_MONTH(currProd));
			numeric enteredPrice = visualValue(PROD_PRICE(currProd));
			string entered;
			if enteredPrice <> NOTAPPL and enteredPrice <> DEFAULT then
				entered = edit("ZZZZZZ9.99", enteredPrice);
			endif;
			
			//if prodUnit < 1 then
				//This will be messed with when converting to string and I can't find a
			
			string unitString = edit("ZZZZZ9.99", prodUnit);
			string lastMonthString = edit("ZZZZZZ9.99", lastMonth);
			
			string msg = makeText(tr(158)) + "\n" + description + "\n(" + makeText(tr(159))
						+ " " + unitString 	+ " " + makeText(tr(160)) 
						+ lastMonthString + ")";
						
			price = toNumber(prompt(msg, entered, numeric));
			while price = DEFAULT do
				errmsg(tr(138));
				price = toNumber(prompt(msg, entered, numeric));
			enddo;
	
			//Check if price is within boundaries:
			//Current version is that the price should be exactly the same. Othewise pop up question about why
			if price <> 0 and lastmonth <> 0 and lastmonth <> NOTAPPL  and price <> lastmonth then
						//(price < lastMonth * 0.9 or price > lastMonth * 1.1) then
				numeric choice = accept(maketext(tr(115), 10), tr(116), tr(117));
				if choice = 1 then
					//Change the price entered.. Just continue looping
				else
					//Give reason for change. Getting the value set of the PROD_COMMENTS to choose from
					change = PROD_COMMENTS_VS.show(tr(117));
					break;
				endif;
			elseif price = 0 then
				numeric choice = accept(tr(132), tr(133), tr(134), tr(135), tr(136));
				if choice = 3 or choice = 4 then	
					//Need replacement of the product/ Change of unit
					string tmp = prompt(maketext(tr(136)), PROD_DESC(currProd));
					PROD_DESC(currProd) = tmp;
					tmp = prompt(maketext(tr(137)));	//unit of new product
					//errmsg("Unit: %s", tmp);
					numeric aUnit = toNumber(tmp);
					if aUnit = DEFAULT then
						tmp = prompt(maketext(tr(138)));	//Please enter number
						aUnit = toNumber(tmp);
					endif;	
					
					//errmsg("as number: %f", aUnit);
					PROD_UNIT(currProd) = aUnit;
					tmp = prompt(tr(158) + PROD_DESC(currProd));
					price = toNumber(tmp);
					PROD_PRICE_LAST_MONTH(currprod) = NOTAPPL;
					
					//Also put it in "last month's prices" - in case the application is shut down and opened again 
					P_MISTO = visualValue(MISTO_NO);
					P_SHOP = visualValue(SHOP);
					P_SHOP_TYPE = visualValue(SHOP_TYPE);
					P_PRODUCT = visualValue(PROD_NO(currProd));
					P_SUBID = visualValue(PROD_SUB_ID(currProd));
					P_COICOP = PROD_COICOP(currProd);
					P_PROD_DESC = PROD_DESC(currProd);
					P_UNIT = visualValue(PROD_UNIT(currProd));
					P_PRICE = 0;	//As this is actually price last month: Setting it to 0
					numeric ok = writecase(PRODUCTS_DICT);  
					
					errmsg(tr(161), PROD_DESC(currProd), visualValue(PROD_UNIT(currProd)));
										
					break;
				else	//OK. product is just out of season
					break;
				endif;	
			else	//Price within boundaries or last month's price is missing..
				break;
			endif;
		enddo;
	
		//Put the price in the roster
		i = 1;
		PROD_PRICE(currProd) = price;
		if change <> NOTAPPL then
			PROD_COMMENTS(currProd) = change;
		endif;
		
		//Also want the current product to be marked as finished
		prodDescr(idx) = maketext(tr(154)) + prodDescr(idx);
		reenter;
		
	else  		//$ = 999. Enumerator wants to quit collecting prices for this product group/shop
		if SHOP_TYPE in 1,2 then
			reenter PRODGROUP;
		else
			//Just continue to ENDQUEST
		endif;
	endif;
	
	
	
PROC ENDQUEST
preproc
	//Checkin first if finished.. Only partial save if not
	//Codes for finished: 0 = finished, 1 = not finished - there are empty fields
	
	numeric finished = 0; //assuming we're finished
	numeric k;
	
	//First, if not all PRODGROUP items end in "finished", we're not finished.. :)
	if menulabels(0) <> "" then	//Not applicable for monitoring survey where we do not use prodgroup
			do k = 0 while k < vsetMax
			string finishedString = maketext(154);
			if pos(finishedString, menulabels(k)) = 0  and  menulabels(k) <> makeText(105) and menuLabels(k) <> "" then
				//Not finished. at least one of the prodgroups does not start with the word "Finished"
				finished = 1;
				break;
			endif;
		enddo;
	endif;
	
	string remainingItems = "";
	if finished = 0 then
		// all PRODGROUP items had status "finished" (or this is monitoring survey). Checking all fields as well
		do k = 1 while k <= maxNumOfItems
			if visualValue(PROD_NO(k)) <> NOTAPPL and visualValue(PROD_PRICE(k)) = NOTAPPL then
				finished = 1;	//Not finished
				break;
			//elseif visualValue(PROD_NO(k)) <> NOTAPPL and visualValue(PROD_PRICE(k)) = 888 then
				//The enumerator said he was going to register these prices later
				//finished = 2;
				//remainingItems = remainingItems + edit("999999", visualValue(PROD_NO(k))) 
				//		+ " - " + strip(PROD_DESC(k)) + ", ";
			endif;
		enddo;
	endif;
	
	if finished = 0 then
		$ = 0;	//All finished
	else
		$ = 1;	//Not finished
	endif;

	noinput;


PROC PRODUCTS_FORM
preproc
	if ENDQUEST <> NOTAPPL then
		skip to DUMMY;
	endif;
	
PROC DUMMY
//Default behaviour of cspro is to go to the next occurence in a roster if one use the 
//errmsg - select construct to let the user change the price just entered.
//To avoid this, the DUMMY field is used to go back to the current occurence (reEnterIdx)

preproc
	if ENDQUEST = 1 then	//Not quite finished
		errmsg(tr(109));
		savepartial();
		stop(1);
	elseif ENDQUEST = 0 then	//Finished
		$ = 9;	//code to quit
		//NB: The stop command must be in the CPI_QUEST lvl in order to save. Not here
		
	endif;
	
	
